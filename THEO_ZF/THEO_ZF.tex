%!TeX ts-program = xelatex
%!TeX encoding = utf-8 Unicode
\documentclass[ieeetran]{article}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usepackage{changepage}

\title{Einführung in die Theoretische Informatik Zusammenfassung}
\author{Efe Kamasoglu}

\begin{document}

\maketitle

\pagebreak

\section{Grundbegriffe und Grammatiken} % (fold)
\label{sub:grundbegriffe_und_grammatiken}

\subsection{Grundbegriffe} % (fold)
\label{sub:grundbegriffe}
\begin{itemize}
  \item Alpabet $\Sigma$, endliche Menge
  \item Wort/String $w$ über $\Sigma$, endliche Menge von Zeichen aus $\Sigma$
\item $|w|$, Länge des Wortes $w$
\item $\epsilon$, das leere Wort mit der Länge 0
\item Wörter $u$ und $v$, $uv$ ist ihre Konkatenation
\item Wort $w$, $w^n$ definiert durch:
	\begin{itemize}
	  \item $w^0 = \epsilon$
	  \item $w^{n + 1} = ww^n$
	  \item \textit{\underline{Beispiel:} $(ab)^3 = ababab$}
         
	\end{itemize}

\item $\Sigma ^*$, Menge aller Wörter über $\Sigma$
\item Teilmenge $L \subseteq \Sigma ^*$, formale Sprache
	\begin{itemize}
		\item \textit{\underline{Beispiel:} $\emptyset$, $\{\epsilon\}$, $L_1 = \{\epsilon, ab, aabb, aaabbb, ... \} = \{a^nb^n \ | \ n \in \mathbb{N} \}$}
	\end{itemize}
\end{itemize}

\subsection{Operationen auf Sprachen} % (fold)
\label{sub:operationen_auf_sprachen}
Sprachen $A, B \subseteq \Sigma ^*$

\begin{itemize}
	\item \textbf{Konkatenation:} $AB = \{uw \ | \ u \in A \ \wedge \ w \in B \}$
		\begin{itemize}
			\item \textit{\underline{Beispiel:}} $\{ab,b\}\{a,bb\} = \{aba, abbb, ba, bbb\}$
			\item $A^n = \{w_1...w_n \ | \ w_1,...,w_n \in A\} = \underbrace{A...A}_\text{n}$
			\item $A^0 = \{ \epsilon \}, \ A^{n+1} = AA^n$
			\item $A^* = \{w_1...w_n \ | \ n \ge 0 \ \wedge \ w_1,...,w_n \in A\} = \bigcup_{n \in \mathbb{N}}A^n$
				\begin{itemize}
					\item $A^*$ enthält $\epsilon$ immer
				\end{itemize}
			\item $A^+ = AA^* = \bigcup_{n \ge 1}A^n$
				\begin{itemize}
				  \item $\epsilon \in A \ gdw. \ \epsilon \in A^+$
				\end{itemize}

		\end{itemize}
	\item \textbf{Kartesisches Produkt:} $A \times B$
		\begin{itemize}
			\item \textit{\underline{Beispiel:}} $\{ab,b\} \times \{a,bb\} = \{(ab,a),(ab,bb),(b,a),(b,bb)\}$
		\end{itemize}
	
\item \textbf{Rechenregeln über Sprachen:}
	\begin{itemize}
		\item Für alle $A$: $\epsilon \in A^*$
	\item $\epsilon \not\in \emptyset$
	\item $\emptyset^* = \{\epsilon\} = \emptyset^0$
	\item $A\{\epsilon\} = \{\epsilon\}A = A$
	\item $A\emptyset= \emptyset A = \emptyset$
	\item $A \times \emptyset = \emptyset$
	\item $A(B \cup C) = AB \cup AC$
	\item $(A \cup B)C = AC \cup BC$
	\item $A(B \cap C) = AB \cap AC$ gilt i.A. \textbf{nicht}
	\item $A(B \setminus C) = AB \setminus AC$ gilt i.A. \textbf{nicht}

	\item $A^*A^* = (A^*)^* = A^*$
	\end{itemize}
\end{itemize}

\subsection{Grammatiken} % (fold)
\label{sub:grammatiken}
\begin{itemize}
	\item Grammatik, 4-Tupel $G = (V, \Sigma, P, S)$
\begin{itemize}
	\item $V$, endliche Menge von \textbf{Nichtterminalen}
	\item $\Sigma$, endliche Menge von \textbf{Terminalen}, disjunkt von $V$
	\item $P \subseteq (V \cup \Sigma)^* \times (V \cup \Sigma)^*$, Menge von \textbf{Produktionen}
	\item $S \in V$, \textbf{Startsymbol}
\end{itemize} 

\item Eine Grammatik G induziert eine \textbf{Ableitungsrelation} $\rightarrow_G$ auf Wörtern über $V \cup \Sigma$:
\begin{itemize}
  \item $\alpha \rightarrow \alpha'$ gdw.\ es eine Regel $\beta \rightarrow \beta'$ in $P$ und Wörter $\alpha_1, \alpha_2$ gibt, so dass $\alpha = \alpha_1 \beta \alpha_2 \ \wedge \ \alpha' = \alpha_1 \beta' \alpha_2$
\end{itemize}

\item Eine \textbf{Sequenz} $\alpha_1 \rightarrow_G \alpha_2 \rightarrow_G ... \rightarrow_G \alpha_n$ ist eine \textbf{Ableitung} von $\alpha_n$ aus $\alpha_1$.
\item Wenn $\alpha_1 = S$ und $\alpha_n \in \Sigma^*$, dann \textbf{erzeugt} $G$ das Wort $\alpha_n$.\ Erzeugte Wörter bestehen nur aus \textbf{Terminalzeichen}.

\item Die Sprache von $G$ ist die Menge aller Wörter ($\Sigma^*$), die von $G$ erzeugt werden: $L(G)$

\item \textbf{Chomsky Hierarchie:} Eine Grammatik $G$ ist vom
\begin{itemize}
  \item \textbf{Typ 0} immer
\item \textbf{Typ 1} falls für jede Produktion $\alpha \rightarrow \beta$ ausser $S \rightarrow \epsilon$ gilt $|\alpha| \le |\beta|$
\item \textbf{Typ 2} falls $G$ vom Typ 1 ist und für jede Produktion $\alpha \rightarrow \beta$ gilt $\alpha \in V$

\item \textbf{Typ 3} falls $G$ vom Typ 2 ist und für jede Produktion $\alpha \rightarrow \beta$ ausser $S \rightarrow \epsilon$ gilt
$\beta \in \Sigma \cup \Sigma V$

\item Typ 3 $\subset$ Typ 2 $\subset$ Typ 1 $\subset$ Typ 0
\item $L$(Typ 3) $\subset$ $L$(Typ 2) $\subset$ $L$(Typ 1) $\subset$ $L$(Typ 0)
 
\end{itemize}
\pagebreak

\item \textbf{Grammatiken und Sprachklassen:}
	\begin{itemize}
		\item \textbf{Typ 3, Rechtslineare Grammatik, Reguläre Sprachen} 
		\item \textbf{Typ 2, Kontextfreie Grammatik, Kontextfreie Sprachen} 
	\item Typ 1, Kontextsensitive Grammatik, Kontextsensitive Sprachen
		\item Typ 0, Phrasenstrukturgrammatik, Rekursiv aufzählbare Sprachen
	\end{itemize}
\end{itemize}


\section{Reguläre Sprachen} % (fold)
\label{sec:reguläre_sprachen}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\linewidth]{regausgram.png}
  \label{fig:regausgram_png}
\end{figure}

\subsection{Rechtslineare Grammatik} % (fold)
\label{sub:rechtslineare_grammatik}
$X,Y \in V$, Produktionen folgender Gestalt:
\begin{itemize}
  \item $X \rightarrow aY$
\item $X \rightarrow a$

\item $X \rightarrow Y$
\item $X \rightarrow \epsilon$, nur dann wenn $X$ Startsymbol ist
\end{itemize}



\subsection{Deterministische endliche Automaten (DFA)} % (fold)
\label{sub:deterministische_endliche_automaten_dFA_}

\begin{itemize}
  \item DFA, 5-Tupel $M = (Q,\Sigma,\delta,q_0, F)$
	 \begin{itemize}
	   \item $Q$, endliche Menge von \textbf{Zuständen}
	\item $\Sigma$, endliches \textbf{Eingabealphabet} 
	\item $\delta : \ Q \times \Sigma \rightarrow Q$, totale \textbf{Übergangsfunktion}
	\item $q_0 \in Q$, ein \textbf{Startzustand}
	\item $F \subseteq Q$, endliche Menge von \textbf{Endzuständen} 
	 \end{itemize}

 \item Die von DFA $M$ \textbf{akzeptierte} Sprache ist $L(M) = \{ w \in \Sigma^* \ | \ \hat{\delta}(q_0,w) \in F \}$, wobei $\hat{\delta}: \ Q \times \Sigma^* \rightarrow Q$ induktiv definiert durch:
	 \begin{itemize}
		 \item $\delta(q,a)$, Zustand, den man aus $q$ mit einem \textbf{Zeichen} $a$ erreicht
		 \item $\hat{\delta}(q,w)$, Zustand, den man aus $q$ mit einem \textbf{Wort} $w$ erreicht
		 \item $\hat{\delta}(q,\epsilon) = q$
		 \item $\hat{\delta}(q,aw) = \hat{\delta}(\delta(q,a),w)$ für $a \in \Sigma, w \in \Sigma^*$

	 \end{itemize}
\end{itemize}

\subsection{Nicht-Deterministische endliche Automaten (NFA)} % (fold)
\label{sub:nicht_deterministische_endliche_automaten_nFA_}
\begin{itemize}
  \item NFA, 5-Tupel $N = (Q,\Sigma,\delta,q_0,F)$
	  \begin{itemize}
	    \item $Q, \Sigma, q0$ und $F$ wie beim DFA
	    \item $\delta: \ Q \times \Sigma \rightarrow \mathcal{P}(Q)$, wobei $\mathcal{P}(Q)$ Menge aller Teilmengen von $Q$
	  \end{itemize}


  \item Die von NFA $N$ \textbf{akzeptierte} Sprache ist $L(N) = \{ w \in \Sigma^* \ | \ \hat{\overline{\delta}}(\{q_0\},w) \cap F \neq \emptyset \}$, wobei
	  \begin{itemize}
		  \item $\overline{\delta}(S,a) = \bigcup_{q \in S}\delta(q,a)$, Menge aller Zustände, die man von einem Zustand in $S$ aus mit einem \textbf{Zeichen} $a$ erreicht
		  \item $\hat{\overline{\delta}}(S,w)$, Menge aller Zustände, die man von einem Zustand in $S$ aus mit einem \textbf{Wort} $w$ erreicht
		  \item $\overline{\delta}: \ \mathcal{P}(Q) \times \Sigma \rightarrow \mathcal{P}(Q)$
		  \item $\hat{\overline{\delta}}: \ \mathcal{P}(Q) \times \Sigma^* \rightarrow \mathcal{P}(Q)$	  
\end{itemize}
\end{itemize}

\subsection{Rechtslineare Grammatik $\rightarrow$ NFA} % (fold)
\label{sub:nFA_rechtslineare_grammatik}
\begin{enumerate}
	\item Füge einen Zustand für jedes Nichtterminal, Startsymbol wird zum Startzustand
	\item Füge einen Endzustand für jedes Terminal, falls es $S \rightarrow \epsilon$ gibt, dann Startzustand ist auch ein Endzustand
	\item Für jede Kombination $Y \rightarrow aX$ füge eine Kante von $Y$ nach $X$ mit dem Zeichen $a$
	\item Für jede Kombination $Y \rightarrow a$ füge eine Kante von $Y$ nach dem Endzustand mit dem Zeichen $a$
\end{enumerate}

\textit{\underline{Beispiel:}}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\linewidth]{gramtonfa}
  \label{fig:gramtonfa}
\end{figure}

\subsection{NFA $\rightarrow$ DFA, Potenzmengenkonstruktion} % (fold)
\label{sub:nFA_dFA_potenzmengenkonstruktion}
Für jede NFA mit $n$ Zuständen kann der DFA max bis zu $2^n$ Zustände haben.

\begin{enumerate}
  \item Für alle Zustände wiederhole (beginnend mit Startzustand $q_0$):
     \begin{enumerate}
       \item Bestimme wohin man mit welcher Kante geht
	\item Erzeuge neue Zustände durch Vereinigung der auf der rechten Seite stehenden Zuständen mit der selben Kanten, verbinde diese
        \item \textbf{Mindestens einer von den Zuständen}, die in dem neuen Zustand sind, ist ein \textbf{Endzustand} $\rightarrow$ der neue Zustand wird ein Endzustand
     \end{enumerate}
\end{enumerate}

\hspace{-0.65cm} \textit{\underline{Beispiel:}}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\linewidth]{nfatodfa.png}
  \label{fig:nfatodfa_png}
\end{figure}

\subsection{$\epsilon$-NFA} % (fold)
\label{sub:__epsilon_nFA}
\begin{itemize}
  \item Ein NFA mit \textbf{$\epsilon$-Übergängen} ist ein NFA mit $\epsilon \not\in \Sigma$ und $\delta: \ Q \times (\Sigma \ \cup \ \{\epsilon\}) \rightarrow \mathcal{P}(Q)$
\end{itemize}

\subsection{$\epsilon$-NFA $\rightarrow$ NFA} % (fold)
\label{sub:_epsilon_nFA_rightarrow_nFA}

\begin{enumerate}
  \item Lösche überflüssige Zustände:
	  
	  \begin{tikzpicture}[node distance=2cm,on grid,auto] 
	     \node[state] (q_0) {$q_0$}; 
	     \node[state] (q_1) [right=of q_0] {$q_1$}; 
	     \node[state] (q_2) [right=of q_1] {$q_2$}; 	      
	     \path[->] 
	      (q_0) edge  node {$\epsilon$} (q_1)
	      (q_1) edge  node {$\epsilon$} (q_2); 
	  \end{tikzpicture}
	 
\item Verbinde die Zustände in der Form mit einer einzigen Kante:

	\begin{tikzpicture}[node distance=2cm,on grid,auto] 
	     \node[state] (q_0) {$q_0$}; 
	     \node[state] (q_1) [right=of q_0] {$q_1$};
	     \node[state] (q_2) [right=of q_1] {$q_2$};
	     \node[state] (q_3) [right=of q_2] {$q_3$};
	     \path[->] 
	      (q_0) edge  node {$\epsilon$} (q_1)
	      (q_1) edge  node {$a$} (q_2)
              (q_2) edge  node {$\epsilon$} (q_3);
	  \end{tikzpicture}
	  \\ wird zu

	  \begin{tikzpicture}[node distance=2cm,on grid,auto] 
	     \node[state] (q_0) {$q_0$}; 
	     \node[state] (q_3) [right=of q_0] {$q_3$}; 
	     \path[->] 
	      (q_0) edge  node {$a$} (q_3);
	  \end{tikzpicture}

\item Lösche nicht erreichbare Zustände
\item Falls $\epsilon$ in der Sprache ist, dann mache den Startzustand Endzustand
\end{enumerate}



\subsection{Reguläre Ausdrücke (REs)} % (fold)
\label{sub:reguläre_ausdrücke}

\begin{itemize}
  \item Reguläre Ausdrücke sind induktiv definiert:
\begin{itemize}
  \item $\emptyset$
\item $\epsilon$
\item Für jedes $a \in \Sigma$
\item Wenn $\alpha$, $\beta$ RE, auch:
	\begin{itemize}
		\item[-] $\alpha \beta$
		\item[-] $\alpha \ | \ \beta$ = $\alpha + \beta$
		\item[-] $\alpha^*$
	\end{itemize}


\end{itemize}

\item $*$, Kleene'sche Iteration

\item Für RE $\gamma$ ist die Sprache induktiv definiert:
	\begin{itemize}
	  \item $L(\emptyset) = \emptyset$
	  \item $L(\epsilon) = \{\epsilon\}$
	\item $L(a) = \{a\}$
\item $L(\alpha \beta) = L(\alpha)L(\beta)$
	\item $L(\alpha \ | \ \beta) = L(\alpha) \cup L(\beta)$
	\item $L(\alpha^*) = L(\alpha)^*$
	\end{itemize}
\item $\alpha \equiv \beta$ gdw.\ $L(\alpha) = L(\beta)$
\item \textbf{Rechenregeln über REs:}
	\begin{itemize}
	  \item \textbf{Null und Eins Lemma:}
		  \begin{itemize}
			  \item[-] $\emptyset \ | \ \alpha \equiv \alpha \ | \ \emptyset \equiv \alpha$
			  \item[-] $\emptyset \alpha \equiv \alpha \emptyset \equiv \emptyset$
			  \item[-] $\epsilon \alpha \equiv \alpha \epsilon \equiv \alpha$
			  \item[-] $\emptyset^* \equiv \epsilon$
			  \item[-] $\epsilon^* \equiv \epsilon$

		  \end{itemize}

\item \textbf{Assoziativität:}
	\begin{itemize}
		\item[-] $(\alpha \ | \ \beta) \ | \ \gamma \equiv \alpha \ | \ (\beta \ | \ \gamma)$
		\item[-] $\alpha (\beta \gamma) \equiv (\alpha \beta) \gamma$
	\end{itemize}

\item \textbf{Kommutativität:}
	\begin{itemize}
		\item[-] $\alpha \ | \ \beta \equiv \beta \ | \ \alpha$
	\end{itemize}

\item \textbf{Distributivität:}
	\begin{itemize}
		\item[-] $\alpha (\beta \ | \ \gamma) \equiv \alpha \beta \ | \ \alpha \gamma$
		\item[-] $(\beta \ | \ \gamma) \alpha \equiv \beta \alpha \ | \ \gamma \alpha$
	\end{itemize}

\pagebreak
\item \textbf{Idempotenz:}
	\begin{itemize}
		\item[-] $\alpha \ | \ \alpha \equiv \alpha$
	\end{itemize}
	\end{itemize}


\item \textbf{Stern Lemma:}
	\begin{itemize}
		\item[-] $\epsilon \ | \ \alpha \alpha^* \equiv \alpha^*$
		\item[-] $\alpha^* \alpha \equiv \alpha \alpha^*$
		\item[-] $(\alpha^*)^* \equiv \alpha^*$
	\end{itemize}
\end{itemize}


\subsection{Strukturelle Induktion für REs} % (fold)
\label{sub:strukturelle_induktion}
Um zu beweisen, dass eine Eigenschaft $P(r)$ für alle regulären Ausdrücke gilt:
\begin{enumerate}
	\item Zeige $P(\emptyset)$
	\item Zeige $P(\epsilon)$
	\item Zeige $P(a)$ für alle $a \in \Sigma$
	\item Unter der Annahme $P(\alpha)$ und $P(\beta)$ (I.H.), zeige $P(\alpha \beta)$ \\$\rightarrow$ verwende $L(\alpha \beta) =L(\alpha)L(\beta)$
	\item Unter der Annahme $P(\alpha)$ und $P(\beta)$ (I.H.), zeige $P(\alpha \ | \ \beta)$ \\$\rightarrow$ verwende $L(\alpha \ | \ \beta) =L(\alpha) \cup L(\beta)$
	\item Unter der Annahme $P(\alpha)$ (I.H.), zeige $P(\alpha^*)$ \\$\rightarrow$ verwende $L(\alpha^*) = L(\alpha)^*$

\end{enumerate}


\hspace{-0.65cm} \textit{\underline{Beispiel:}} $empty(r)$ entscheidet, ob $L(r) = \emptyset$. Zeige die Korrektheit der Konstruktion:

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.65\linewidth]{strukturelleinduktion}
  \label{fig:strukturelleinduktion}
\end{figure}

\pagebreak
\subsection{RE $\rightarrow$ $\epsilon$-NFA} % (fold)
\label{sub:rE_rightarrow_epsilon_nFA}
\begin{enumerate}
	\item Wende folgende Ersetzungsregeln an
		\begin{figure}[h!]
		  \centering
		  \includegraphics[width=0.8\linewidth]{ersetzungretonfa.png}
		  \label{fig:ersetzungretonfa_png}
		\end{figure}

\item Wende folgende Transformationsregeln an
	\begin{figure}[h!]
	  \centering
	  \includegraphics[width=0.8\linewidth]{transformationsregel.png}
	  \label{fig:transformationsregel_png}
	\end{figure}
\end{enumerate}

\textit{\underline{Beispiel:}}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\linewidth]{retonfabeispiel.png}
  \label{fig:retonfabeispiel_png}
\end{figure}
\pagebreak


\subsection{$\epsilon$-NFA $\rightarrow$ RE} % (fold)
\label{sub:_epsilon_nFA_rightarrow_rE}

\begin{enumerate}
	\item Hat Startzustand $q_1$ eingehende Übergänge, füge einen neuen Startzustand $q_0$ mit einem $\epsilon$-Übergang nach $q_1$
	\item Füge einen neuen Endzustand $q_3$ und $\epsilon$-Übergänge nach $q_3$ von allen Endzuständen ($q_2$ in diesem Beispiel)

		\begin{figure}[h!]
		  \centering
		  \includegraphics[width=0.8\linewidth]{nfatoreschritt1.png}
		  \label{fig:nfatoreschritt1_png}
		\end{figure}

\item Wähle ein Zustand $q$, der weder Start- noch Endzustand ist
\item Eliminiere $q$, wende dabei folgende Regeln:
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\linewidth]{nfatoreschritt2.png}
  \label{fig:nfatoreschritt2_png}
\end{figure}
\end{enumerate}

\textit{\underline{Beispiel:}}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.56\linewidth]{nfatorebeispiel1.png}
  \includegraphics[width=0.4\linewidth]{nfatorebeispiel2.png}
  \label{fig:nfatorebeispiel_png}
\end{figure}

\subsection{Ardens Lemma} % (fold)
\label{sub:fA_}
\begin{itemize}
\item Sind $A, B, X$ Sprachen mit $\epsilon \not\in A$, so gilt:
	\large
	\begin{equation*}
	\boxed{
	\begin{aligned}
X = AX \cup B \Longrightarrow X = A^* B	
	\end{aligned}
	}
	\end{equation*}
	\normalsize
	
	\item Sind $\alpha, \beta, X$ REs mit $\epsilon \not\in L(\alpha)$, so gilt:
\large
\begin{equation*}
\boxed{
\begin{aligned}
	X \equiv \alpha X \ | \ \beta \Longrightarrow X \equiv \alpha^* \beta 
\end{aligned}
}
\end{equation*}
\normalsize

\item \textbf{Bemerkungen:}
	\begin{itemize}
		\item $X \equiv X\alpha \ | \ \beta \Longrightarrow X \equiv \beta \alpha^*$
		\item $X \equiv \alpha X \ | \ \beta$ für $\epsilon \in L(\alpha)$
		\begin{itemize}
		\item hat \textbf{keine eindeutige Lösung}: jede Sprache $B \subseteq X$ ist Lösung
		  \item \textit{\underline{Beispiel:}} für $\alpha = \epsilon$ und $\beta = b$ kann $X = b$ oder $X = a \ | \ b$ oder $X = aba \ | \ b$
		\end{itemize}
	
	\item $X \equiv X \ | \ aX$
		\begin{itemize}
		  \item hat \textbf{keine eindeutige Lösung:} $X = \emptyset$ oder $X = \Sigma^*$ oder $X = a^*$
		\end{itemize}
	
		\item $X \equiv \alpha X$ für $\epsilon \not\in L(\alpha)$
			\begin{itemize}
			  \item hat \textbf{eine eindeutige Lösung:} $X = \emptyset$
			\end{itemize}
		\item $X \equiv \alpha X$ für $\epsilon \in L(\alpha)$
			\begin{itemize}
				\item hat \textbf{keine eindeutige Lösung:} $X = \Sigma^*$ oder $X = ab^*a$
			\end{itemize}

		\item $X \equiv aXb \ | \ \epsilon$
			\begin{itemize}
				\item hat \textbf{keine reguläre Lösung:} $X = L$ für $L = \{a^nb^n, n \ge 0\}$

			\end{itemize}
			\item $X \equiv abX \ | \ \epsilon$
			\begin{itemize}
			  \item hat \textbf{eine eindeutige Lösung:} $X = (ab)^*\epsilon = (ab)^*$
			\end{itemize}
	\end{itemize}

\end{itemize}

\subsection{FA $\rightarrow$ RE mittels Ardens Lemma} % (fold)
\label{sub:fA_rightarrow_rE}
\begin{enumerate}
  \item FA als Gleichungssystem schreiben 
\begin{itemize}
  \item für jeden Endzustand $X_f$ füge $X_f \equiv \epsilon$ ein
\item für jeden Zustand $X$ mit 
	
	\begin{tikzpicture}[node distance=2cm,on grid,auto] 
	   \node[state] (X) {$X$}; 
	   \node[state] (X_1) [right=of X] {$X_1$}; 
	    \path[->] 
	    (X) edge  node {a} (X_1);
	\end{tikzpicture}

mache $X \equiv aX_1$
	
\end{itemize}

\item Gleichungen einsetzen und damit eliminieren
\item Rechenregeln über REs und Ardens Lemma verwenden
\end{enumerate}


\subsection{Konversionen bezüglich regulärer Sprachen} % (fold)
\label{sub:konversionen_bezüglich_regulärer_sprachen}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.46\linewidth]{konversionregular}
  \label{fig:konversionregular}
\end{figure}



\subsection{Abschlusseigenschaften regulärer Sprachen} % (fold)
\label{sub:abschlusseigenschaften_regulärer_sprachen}
Seien $L, L_1, L_2 \subseteq \Sigma^*$ reguläre Sprachen, dann sind auch
\begin{itemize}
  \item $L_1 L_2$
\item $L_1 \cup L_2$, $L_1 \cap L_2$, $L_1 \setminus L_2$
\item $\overline{L}$ bzw. $\Sigma^* \setminus L$

\item $L^*$
\item $L^R$ (Spiegelung von $L$)
\item $L_1 \times L_2$
\end{itemize}

\subsection{Komplementierung $\overline{L}$ bezüglich FAs} % (fold)
\label{sub:komplementierung_bezüglich_fAs}
\begin{itemize}
  \item \textbf{Für DFAs:} Vertauschen von Endzuständen und Nicht-Endzuständen
\item \textbf{Für NFAs:} funktioniert das Vertauschen \textbf{nicht} 
\end{itemize}

\subsection{Schnitt zweier DFAs, Produktkonstruktion} % (fold)
\label{sub:produktkonstruktion}
\begin{itemize}
	\item Sind $M_1$ und $M_2$ DFAs. Dann ist der \textbf{Produkt-Automat} $\mathbf{M}$ mit $L(M) = L(M_1) \cap L(M_2)$.

	\item \textbf{Produktkonstruktion für $M_1$ und $M_2$:}
		\begin{enumerate}
			\item Erzeuge einen neuen Startzustand aus den Startzuständen der $M_1$ und $M_2$
			\item Bestimme wohin man mit welcher Kante geht
			\item Erzeuge neue Zustände durch Vereinigung der auf der rechten Seite stehenden Zuständen mit der selben Kanten, verbinde diese
			\item \textbf{Alle Zustände}, die in dem neuen Zustand sind, sind \textbf{Endzustände} $\rightarrow$ der neue Zustand wird ein Endzustand
		\end{enumerate}
\end{itemize}

\subsection{Vereinigung zweier DFAs} % (fold)
\label{sub:vereinigung_zweier_dFAs}
\begin{itemize}
\item Sind $M_1$ und $M_2$ DFAs. Dann ist $M$ mit $L(M) = L(M_1) \cup L(M_2)$.
\item \textbf{Konstruktion für $M_1$ und $M_2$:}
Gleich wie die Produktkonstruktion bis auf 4.
\begin{enumerate}
	\item[4.] \textbf{Mindestens einer von den Zuständen}, die in dem neuen Zustand sind, ist ein \textbf{Endzustand} $\rightarrow$ der neue Zustand wird ein Endzustand
\end{enumerate}
\end{itemize}

\subsection{Pumping Lemma für reguläre Sprachen} % (fold)
\label{sub:pumping_lemma}
\begin{itemize}
	\item Sei $L \subseteq \Sigma^*$ regulär. Dann gibt es ein $n > 0$, so dass sich jedes $z \in L$ mit $|z| \ge n$ so in $z = uvw$ zerlegen lässt, dass
\begin{enumerate}
  \item $v \neq \epsilon$
\item $|uv| \le n$
\item $\forall i \ge 0.$ $uv^iw \in L$
\end{enumerate}
  \item Um zu zeigen, dass eine Sprache \textbf{nicht regulär} ist $\rightarrow$ \textbf{Regulärität} mit Pumping Lemma zu zeigen \textbf{nicht möglich}
  \item Es gibt nicht-reguläre Sprachen, für die das Pumping-Lemma gilt \\$\rightarrow$ regulär $\subset$ Pumping Lemma gilt $\subset$ alle Sprachen

  \item \textit{\underline{Beispiel:}} $L = \{0^{m^{2}} \ | \ m \ge 0\}$
\\ \\ Angenommen $L$ sei regulär.
\\Sei $n$ eine Pumping-Lemma-Zahl für $L$.
\\Wähle $z = 0^{n^{2}} \in L$. Sei $uvw$ eine Zerlegung von $z$ mit $1 \le |v| \le |uv| \le n$.
\\ Zeige, dass $uv^iw \not\in L$ für den Fall $i = 2$ gilt:
\\ $n^2 = |z| = |uvw| < |uv^2w| \le n^2 + n \le n^2 + 2n + 1 = (n + 1)^2$
\\ Da es keine Quadratzahl zwischen $n^2$ und $(n+1)^2$ geben kann, ist $uv^2w \not\in L$, damit ist $L$ nicht regulär.


\end{itemize}

\subsection{Entscheidungsprobleme für reguläre Sprachen} % (fold)
\label{sub:entscheidungsprobleme_für_reguläre_sprachen}
\begin{itemize}
  \item \textbf{Wortproblem:} Gegeben $w$ und $D$, gilt $w \in L(D)$?
\begin{itemize}
	\item für DFA $M$, in $O(|w| + |M|\footnote{Konstante für die Entscheidung, ob der Zustand den wir am Ende erreichen, ein Endzustand ist})$ entscheidbar
\item für NFA $N$, in $O(|Q|^2|w| + |N|)$ entscheidbar
\end{itemize}

\item \textbf{Leerheitsproblem:} Gegeben $D$, gilt $L(D) = \emptyset$?
\begin{itemize}
	\item für DFA $M$, in $O(|Q||\Sigma|)$ entscheidbar
\item für NFA $N$, in $O(|Q|^2|\Sigma|)$ entscheidbar
\end{itemize}

\pagebreak

\item \textbf{Endlichkeitsproblem:} Gegeben $D$, ist $L(D)$ endlich?
\begin{itemize}
	  \item für DFA und NFA entscheidbar
	\item $L(M) = \infty$ gdw.\ vom Startzustand aus eine nicht-leere Schleife erreichbar ist, von der aus $F$ erreichbar ist
	\begin{figure}[h!]
	  \centering
	  \includegraphics[width=0.5\linewidth]{endlichkeitsproblem}
	  \label{fig:endlichkeitsproblem}
	\end{figure}
\end{itemize}

\item \textbf{Äquivalenzproblem:} Gegeben $D_1$ und $D_2$, gilt $L(D_1) = L(D_2)$?
\begin{itemize}
\item schaue, ob $L(M_1) \cap \overline{L(M_2)} = \emptyset$ und $\overline{L(M_1)} \cap L(M_2) = \emptyset$ gelten
	\item für DFAs, in $O(|Q_1||Q_2||\Sigma|)$ entscheidbar
	\item für NFA $N$, in $O(2^{|Q_1| +|Q_2|})$ entscheidbar (bei fixem $\Sigma$)
\end{itemize}\end{itemize}

\subsection{Minimierung von FAs} % (fold)
\label{sub:minimierung_der_fAs}
\begin{itemize}
	\item Zustände $p$ und $q$ sind \textbf{unterscheidbar}, wenn $\exists w \in \Sigma^*$ mit $\hat{\delta}(p,w) \in F$ und $\hat{\delta}(q,w) \not\in F$ oder umgekehrt
\item Zustände $p$ und $q$ sind \textbf{äquivalent}, wenn $\forall w \in \Sigma^*$ mit $\hat{\delta}(p,w) \in F$ $\Leftrightarrow$ $\hat{\delta}(q,w) \in F$
\item Gilt $p \in F$ und $q \not\in F$, dann sind $p$ und $q$ unterscheidbar
\item Sind $\delta(p,a)$ und $\delta(q,a)$ unterscheidbar, dann auch $p$ und $q$


\end{itemize}

\subsection{Minimierungsalgortihmus für DFAs} % (fold)
\label{sub:minimierungsalgortihmus_für_dFAs}

\begin{enumerate}
  \item Konstruiere die Treppe $\forall q \in Q$
  \item Markiere Endzustände und Nichtendzustände mit einem $\epsilon$
  \item Für alle unmarkierten Paare $(q, p)$: Falls $(\delta(q, a), \delta(p, a))$ markiert, markiere das Paar $(q,p)$ mit $a$
	  \begin{enumerate}
	    \item Falls es $b$ im Kästchen von $(\delta(q, a), \delta(p, a))$ gibt, dann markiere das Paar $(q,p)$ mit $ab$
	  \end{enumerate}
  \item Für alle unmarkierten Paare $(q, p)$: Schmelze $q$ und $p$ zusammen, evtl. markiere das Paar mit $=$
\end{enumerate}

\pagebreak

\textit{\underline{Beispiel:}}

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.65\linewidth]{minimierungdfa1}
  \includegraphics[width=0.3\linewidth]{minimierungdfa2}
  \label{fig:minimierungdfa1}
\end{figure}


\subsection{Äquivalenz von Zuständen eines DFAs} % (fold)
\label{sub:äquivalenz_von_zuständen_eines_dFAs}
\begin{itemize}
	\item \textbf{Äquivalenzklasse:} $[p]_{\equiv_M} = \{q \ | \ p \equiv_M q\}$, Menge der Zustände, die mit $p$ äquivalent sind
	\item \textbf{Quotientenmenge:} $Q/\!\equiv_M \  = \{ [p]_{\equiv_M} \ | \ p \in Q\}$, Menge der Äquivalenzklassen

  \item $p \equiv_M q \Leftrightarrow L_M(p) = L_M(q)$
\begin{itemize}
	\item $L_M(q) = \{w \in \Sigma^* \ | \ \hat{\delta}(q,w) \in F\}$, Sprache vom Zustand $q$
  \item Zwei Zustände sind äquivalent wenn sie die gleiche Sprache erkennen
\item \textbf{Fakt:} $|Q/\!\equiv_M \!|$ = Anzahl der Sprachen, die von Zuständen von $M$ erkannt werden


\end{itemize}
\item \textbf{Quotientenautomat:} $M/ \!\equiv \ = (Q/\!\equiv, \Sigma, \delta',[q_0]_{\equiv}, F/\!\equiv)$ mit $\delta'([p]_{\equiv}, a) = [\delta(p,a)]_{\equiv}$
\item Quotientenautomat $M/\!\equiv$ ist ein \textbf{minimaler DFA} für $L(M)$
\item $L(M/\!\equiv) = L(M)$\end{itemize}
\subsection{Residualsprache, Äquivalenz von Wörtern} % (fold)
\label{sub:residualsprache}

\begin{itemize}
	\item $L^w = \{z \in \Sigma^* \ | \ wz \in L\}$, Residualsprache von $L$ bzgl. $w \in \Sigma^*$
	\item $u \equiv_L v \Leftrightarrow L^u = L^v$
		\begin{itemize}
		  \item Zwei Wörter sind äquivalent wenn sie die gleiche Residualsprache haben
		\item \textbf{Fakt:} $|\Sigma^*/\!\equiv_L\!|$ = Anzahl der Residualsprachen von $L$
		\end{itemize}

\item \textbf{Fakt:} $|Q/\!\equiv_M\!| = |\Sigma^*/\!\equiv_L\!|$, \textbf{Anzahl der Residualsprachen entspricht der Anzahl der Zustände im minimalen Automat} 
\end{itemize}

\subsection{Myhill-Nerode Relation} % (fold)
\label{sub:myhill_nerode_relation}
\begin{itemize}
   \item Eine Sprache $L$ ist \textbf{regulär} gdw.\ Anzahl der Residualsprachen von $L$ \textbf{endlich} 

   \item \textbf{Beweis mittels Myhill-Nerode Relation:} $L=\{a^ib^ic^i \ | \ i \in \mathbb{N}\}$
	   \begin{enumerate}
		   \item Bestimmen einer unendliche Menge von Wörtern mit unterschiedlichen Residualsprachen: $\{a^ib^i \ | \ i \in \mathbb{N}\}$
		   \item Sei $i,j \in \mathbb{N}$ verschieden. Dann $a^ib^ic^i \in L$, aber $a^jb^jc^i \not\in L$. Daher $L^{a^ib^i} \neq L^{a^jb^j}$.
		\item Somit sind alle Residualsprachen unterschiedlich und $L$ \textbf{keine reguläre} Sprache
	   \end{enumerate}
\end{itemize}







\subsection{Kanonischer Minimalautomat} % (fold)
\label{sub:kanonischer_minimalautomat}

\begin{itemize}
	\item $M_L = \{R_L, \Sigma, \delta_L, L, F_L\}$ mit $\delta_L(R,a) = R^a$ und $F_L = \{R \in R_L \ | \ \epsilon \in R\}$, kanonischer Minimalautomat $M_L$ mit $L(M_L) = L$
	\item $R_L$, Menge der Residualsprachen von $L$ 

\item \textbf{Durch Umbenennung von Zuständen} von jedem minimalen DFA bekommt man den \textbf{kanonischen Minimalautomat}

\item Kanonischer Minimalautomat $M_L$ ist \textbf{gleich gross} wie Quotientenautomat und damit ein \textbf{minimaler DFA} für $L(M)$

\item \textit{\underline{Beispiel:}} $L = L((bba \ | \ bab)^*)$ mit $\Sigma = \{a, b\}$
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\linewidth]{kanonischerdfa.png}
  \label{fig:kanonischerdfa_png}
\end{figure}
\end{itemize}

\subsection{Regulärität der Sprachen} % (fold)
\label{sub:regulärität_der_sprachen}
Eine Sprache ist \textbf{regulär}

\begin{itemize}
  \item gdw.\ sie von einer \textbf{DFA, NFA, $\epsilon$-NFA, RE, rechtslinearen Grammatik akzeptiert wird}
\item gdw.\ sie durch \textbf{Abschlusseigenschaften der regulären Sprachen} entsteht

\item gdw.\ sie \textbf{endliche Anzahl von Residualsprachen hat}
\end{itemize}

\pagebreak

\hspace{-0.65cm} Eine Sprache ist \textbf{nicht regulär}
\begin{itemize}
	\item gdw.\ für sie \textbf{Pumping-Lemma nicht gilt}
	\item gdw.\ sie \textbf{unendliche Anzahl von Residualsprachen hat (Myhill-Nerode)}
\end{itemize}
\section{Kontextfreie Sprachen (CFL)} % (fold)
\label{sec:kontextfreie_sprachen}

\subsection{Kontextfreie Grammatik (CFG)} % (fold)
\label{sub:kontextfreie_grammatik_cFG}
\begin{itemize}
	\item Kontextfreie Grammatik $G = (V, \Sigma, P, S)$ mit $P \subseteq V \times (V \cup \Sigma)^*$
  \item Produktionen folgender Gestalt:
\begin{itemize}
  \item $X \rightarrow \alpha$, mit $\alpha \in (V \cup \Sigma)^*$
\end{itemize}

\item $\alpha_1 \rightarrow_G \alpha_2 \rightarrow_G \ldots \rightarrow_G \alpha_n$ nennt man eine \textbf{Linksableitung} gdw.\ in jedem Schritt \textbf{das linkeste Nichtterminal} in $\alpha_i$ ersetzt wird
\item \textbf{Rechtsableitung} analog zu Linksableitung
\end{itemize}

\subsection{Induktive Definition einer Sprache mittels Grammatik} % (fold)
\label{sub:induktive_definition}

\begin{itemize}
  \item Sei $G$ eine Grammatik: $S \rightarrow \epsilon \ | \ +S-S \ | \ +S \ | \ \epsilon$ 
\item Um zu zeigen, dass $G$ die Menge aller \textit{nicht überziehenden} Wörter erzeugt, betrachten wir die Grammatik als \textbf{induktive Definition einer Sprache $L(G)$}

\item Wort $w$ ist überziehend gdw.\ $\exists i$, sodass $\Delta (w_1 \ldots w_i) < 0$ mit $\Delta(w) = |w|_+ - |w|_-$

\item \textbf{nicht überziehend:} $\epsilon, ++-+-$
\item \textbf{überziehend:} $-+, +-+--++$
\item \textbf{Induktive Definition von $L(G)$:}
\begin{itemize}
  \item $\epsilon \in L(G)$
  \item $u \in L(G) \Longrightarrow +u \in L(G)$
\item $u \in L(G) \land v \in L(G) \Longrightarrow +u-v \in L(G)$
\end{itemize}	

\item Produktionen ($\rightarrow$) erzeugen Wörter \textbf{top-down}: Nichtterminal $\rightarrow$ Wort
\item Induktive Definition ($\Longrightarrow$) erzeugt Wörter \textbf{buttom-up}: kleinere Wörter $\Longrightarrow$ grössere Wörter
\item Induktive Definition betrachtet nur Wörter aus $\Sigma^*$

\end{itemize}

\pagebreak

\subsection{(Strukturelle) Induktion über die Erzeugung eines Wortes} % (fold)
\label{sub:_strukturelle_induktion_über_die_erzeugung_von_einem_wort}
\begin{itemize}
	\item $w \in L(G) \Longrightarrow$ beweist man mit \textbf{Induktion über Erzeugung von $w$}
 \item Um zu zeigen, dass für alle $u \in L(G)$ eine Eigenschaft $P(u)$ gilt, zeige:
\begin{itemize}
  \item $P(\epsilon)$
  \item $P(u) \Longrightarrow P(+u)$
\item $P(u) \land P(v) \Longrightarrow P(uv)$
\end{itemize}

\item \textit{\underline{Beispiel:}} Grammatik $S \rightarrow \epsilon \ | \ +S-S \ | \ +S \ | \ \epsilon$ erzeugt die Wörter, die nicht überziehend sind.
\begin{itemize}

\item Induktionsbasis: $\epsilon \in L(G)$ ist nicht überziehend
\item Induktionsschritt: Seien $u, v$ nicht überziehende Wörter. Es gibt 2 Fälle:
	\begin{enumerate}
		\item $w=+u$: Für beliebiges $i$ gilt $\Delta(w_1 \dots w_i) = 1 + \Delta(u_1 \ldots u_{i-1})$. Da $u$ nicht überziehend ist, folgt $\Delta(u_1 \ldots u_{i-1}) \ge 0$ und somit $\Delta(w_1 \ldots w_i) \ge 1 \ge 0$. Also ist $w$ auch nicht überziehend.
		\item $w=+u-v$: Für $i \in \{1, \ldots, |u|+2\}$ wissen wir bereits $\Delta(w_1 \ldots w_i) \ge 0$, analog zum ersten Fall. Für $i > |u| + 2$ gilt nun $\Delta(w_1 \ldots w_i) = \Delta(+u-v_1 \ldots v_j)$, mit $j = i - |u| - 2$. Es folgt $\Delta(+u-v_1 \ldots v_j) = \Delta(u) + \Delta(v_1 \ldots v_j) \ge 0$, da sowohl $u$ als auch $v$ nicht überziehend ist.
	\end{enumerate}


\end{itemize}


\end{itemize}

\subsection{Induktion über die Länge des Wortes} % (fold)
\label{sub:induktion_über_die_länge_des_wortes}
\begin{itemize}
	\item $P(w) \Longrightarrow w \in L(G)$ beweist man mit \textbf{Induktion über }$|w|$
	\item \textit{\underline{Beispiel:}} Die nicht überziehenden Wörter werden durch die Grammatik $S \rightarrow \epsilon \ | \ +S-S \ | \ +S \ | \ \epsilon$ erzeugt.
		\begin{itemize}
		\item Induktionsannahme: Für nicht überziehendes $w$ gilt $w \in L(G)$
		  \item Induktionsbasis: Für $|w| = 0$ gilt $w = \epsilon \in L(G)$
\item Induktionsschritt:
	\begin{enumerate}
	  \item Falls $w = +u$ für ein $u$ nicht überziehend, dann wissen wir nach Induktionsannahme, dass $u \in L(G)$. Daraus folgt $S \rightarrow +S-S \rightarrow^* +u = w$ und somit $w \in L(G)$.
	\item Falls $w = +u-v$ für $u,v$ nicht überziehend: Nach Induktionsannahme gilt $u,v \in L(G)$, also erhalten wir $S \rightarrow +S-S \rightarrow^*+u-S \rightarrow^* +u-v = w$ und somit $w \in L(G)$.
	\end{enumerate}
		\end{itemize}
\end{itemize}


\subsection{Syntaxbaum, Mehrdeutigkeit} % (fold)
\label{sub:syntaxbaum}
\begin{itemize}
\item Für eine CFG und ein $w \in \Sigma^*$ sind folgende Bedingungen äquivalent:
	\begin{itemize}
	  \item $A \rightarrow_G^* w$
	\item $w \in L_G(A)$ (induktive Definition)
	\item Es gibt einen Syntaxbaum mit Wurzel $A$, dessen Rand
(Blätter von links nach rechts gelesen) das Wort $w$ ist


\end{itemize}
\item Syntaxbaum für eine Ableitung mit Grammatik $S \rightarrow \epsilon \ | \ [S] \ | \ SS$: $w = \epsilon$, $w = []$, kein gültiges Baum
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.4\linewidth]{syntaxbaum}
  \label{fig:syntaxbaum}
\end{figure}

\item CFG $G$ \textbf{mehrdeutig} gdw.\ es gibt $w \in L(G)$, das \textbf{zwei verschiedene Syntaxbäume} hat
\item CFL $L$ \textbf{inhärent mehrdeutig} gdw.\ \textbf{jede CFG} $G$ mit $L(G) = L$ \textbf{mehrdeutig} 
\item \textit{\underline{Beispiel:}} $S \rightarrow \epsilon \ | \ +S-S \ | \ +S \ | \ \epsilon$ und $w = ++-$ $\Leftrightarrow$ $L_G(S)$ ist mehrdeutig
	\begin{figure}[h!]
	  \centering
	  \includegraphics[width=0.4\linewidth]{syntaxbaum1.png}
	  \label{fig:syntaxbaum1_png}
	\end{figure}



\end{itemize}


\subsection{Chomsky-Normalform (CNF)} % (fold)
\label{sub:chomsky_normalform_cNF_}
\begin{itemize}
  \item Eine CFG $G$ ist in Chomsky-Normalform gdw.\ alle Produktionen eine der Formen haben: $A \rightarrow a$ oder $A \rightarrow BC$
\item $\epsilon$-Produktion: $A \rightarrow \epsilon$
\item Kettenproduktion: $A \rightarrow B$

  \item Zu jeder CFG $G$ kann man eine CFG $G'$ in Chomsky-Normalform konstruieren, die \textbf{keine} $\epsilon$-Produktionen und Kettenproduktionen enthält, so dass gilt $L(G') = L(G) \setminus \{\epsilon\}$

\pagebreak

\item \textbf{Konstruktion:}
	\begin{enumerate}
	  \item Füge für jedes $a \in \Sigma$ mit der Länge $\ge 2$ ein neues Nichtterminal $X_a$ und eine neue Produktion $X_a \rightarrow a$ hinzu:
	\begin{itemize}
		\item $A \rightarrow aBC$ wird zu $A \rightarrow X_aBC$
			\\ \hspace*{2.9cm}$X_a \rightarrow a$
	\end{itemize}

\item Ersetze jede Produktion der Form $A \rightarrow B_1B_2\ldots B_k$ mit der Länge $k \ge 3$:
	\begin{itemize}
		\item $A \rightarrow BCD$ wird zu $A \rightarrow BX_{CD}$
\\ \hspace*{3cm}$X_{CD} \rightarrow CD$

\end{itemize}


\item Eliminiere alle $\epsilon$-Produktionen, indem wir zuerst $\epsilon$ in Produktionen einsetzen und dann eliminieren:
	\begin{itemize}
	  \item $A \rightarrow XY$ wird zu $A \rightarrow X\epsilon$ wird zu $A \rightarrow X$
		  \\$Y \rightarrow \epsilon$ \hspace*{1.6cm} $Y \rightarrow \epsilon$
	\end{itemize}


\item Eliminiere alle Kettenproduktionen, indem wir zuerst Nichtterminale in Produktionen einsetzen und dann eliminieren
	\begin{itemize}
		\item $A \rightarrow X \ | \ YZ$ \hspace*{0.5cm} wird zu \hspace*{0.5cm} $A \rightarrow YZ \ | \ x \ | \ DL \ | \ B$
		  \\ $X \rightarrow x \ | \ DL \ | \ B$ \hspace*{1.8cm} $B \rightarrow b$
\\ $B \rightarrow b$
\item wird zu $A \rightarrow YZ \ | \ x \ | \ DL \ | \ b$
	\end{itemize}
	\end{enumerate}


\end{itemize}

\subsection{Greibach-Normalform} % (fold)
\label{sub:greibach_normalform}
\begin{itemize}
	\item Eine CFG ist in Greibach-Normalform gdw.\ alle Produktionen die Form $A \rightarrow aA_1 \ldots A_n$ haben
	\item Zu jeder CFG $G$ gibt es eine CFG $G'$ in Greibach-Normalform mit $L(G') = L(G) \setminus \{\epsilon\}$
\end{itemize}

\subsection{Pumping Lemma für CFLs} % (fold)
\label{sub:pumping_lemma_für_cFL}
\begin{itemize}
  \item Für jede CFL $L$ gibt es ein $n > 0$, so dass sich jedes Wort $z \in L$ mit $|z| \ge n$ zerlegen lässt in $z = uvwxy$, dass
	  \begin{enumerate}
	    \item $vx \neq \epsilon$ bzw.\ $|vx| \ge 1$
	\item $|vwx| \le n$
	\item $\forall i \ge 0. \ uv^iwx^iy \in L$
	  \end{enumerate}

  \item \textit{\underline{Beispiel:}} $L = \{a^ib^ic^i \ | \ i \in \mathbb{N} \}$
\\\\Angenommen $L$ sei kontextfrei.
\\Sei $n$ eine Pumping-Lemma-Zahl für $L$.
\\Wähle $z = a^nb^nc^n \in L$. Sei $uvwxy$ eine Zerlegung von $z$ mit $vx \neq \epsilon$ und $|vwx| \le n$. Wir betrachten nun 2 Fälle:
\begin{enumerate}
\item $uwx$ enthält nur $a$s oder $b$s oder $c$s: Für $i = 2$ erhalten wir $uv^2wx^2y = a^{i + 2|v| + 2|x|}b^ic^i$. Da $|vx| \ge 1$, gilt $uv^2wx^2y \not\in L$.
\item $uwx$ enthält nur $a$s und $b$s oder $b$s und $c$s: Hier muss $vx$ mindestens ein $a$ und ein $b$ enthalten. Damit gilt aber $|uv^2wx^2y|_a > |uv^2wx^2y|_c$. Also $uv^2wx^2y \not\in L$.
\end{enumerate}


\end{itemize}





\subsection{Erzeugend, Erreichbar, Nützlich} % (fold)
\label{sub:erzeugend_erreichbar_nützlich}
\begin{itemize}
\item Sei $G = (V,\Sigma, P, S)$ CFG. Ein Symbol $X \in V \cup \Sigma$ ist
\begin{itemize}
\item \textbf{erzeugend} gdw.\ es eine Ableitung $X \rightarrow_G^* w \in \Sigma^*$ gibt
\item \textbf{erreichbar} gdw.\ es eine Ableitung $S \rightarrow_G^* \alpha X \beta$ gibt
  \item \textbf{nützlich} gdw.\ erzeugend und erreichbar


\end{itemize}

\item Bekommt man eine Grammatik $G'$ mit $L(G') = L(G)$, die nur \textbf{nützliche Symbole} enthält, durch:
	\begin{enumerate}
	  \item Elimination der \textbf{nicht erzeugenden} Symbole
\item Elimination der \textbf{nicht erreichbaren} Symbole
	\end{enumerate}

\item Menge der erzeugenden Symbole einer CFG ist berechenbar
\item Menge der erreichbaren Symbole einer CFG ist berechenbar
\end{itemize}

\subsection{Cocke-Younger-Kasami-Algorithmus (CYK)} % (fold)
\label{sub:cocke_younger_kasami_algorithmus_cYK_}
\begin{itemize}
  \item \textbf{Wortproblem} ist für eine CFG $G$ mittels CYK-Algorithmus in Zeit $O(|w|^3)$ entscheidbar
	\item \textbf{Algorithmus:} $w \in L(G)$?
		\begin{enumerate}
		  \item Konstruiere die Treppe (Breite = Höhe = $|w|$) und beschrifte jede Spalte von unten nach oben: Für 1. Spalte $1,1-1,2-\ldots-1,|w|$; für 3. Spalte $3,3-3,4-\ldots-3,|w|$
		\item Fülle die erste Reihe mit Nichtterminalen ein, die die einzelnen Buchstaben des Wortes erzeugen
		\item Fülle die anderen Kästchen mit Nichtterminalen nach Beschriftungen ein: Für $1,2$ konkateniere $1,1$ $2,2$; für $1,4$ konkateniere $1,1$ $2,4$ und $1,2$ $3,4$ und $1,3$ $4,4$
		\item Wenn es im Kästchen $1, |w|$ das Startsymbol gibt, dann gilt $w \in L(G)$, wenn nicht $w \not\in L(G)$

		\end{enumerate}

	\item \textit{\underline{Beispiel:}} $baaba \in L(G)$?
		\begin{figure}[h!]
		  \centering
		  \includegraphics[width=0.5\linewidth]{cykexample}
		  \label{fig:cykexample}
		\end{figure}
\end{itemize}

\subsection{Nicht Entscheidbare Probleme für CFGs} % (fold)
\label{sub:nicht_entscheidbare_probleme_für_cFGs}
\begin{itemize}
  \item \textbf{Äquivalenz:} $L(G_1) = L(G_2)$?
\item \textbf{Schnittproblem:} $L(G_1) \cap L(G_2) = \emptyset$?
\item \textbf{Regularität:} $L(G)$ regulär?
\item \textbf{Mehrdeutigkeit:} Ist $G$ mehrdeutig?
\end{itemize}

\subsection{Nicht Deterministischer Kellerautomat (NPDA)} % (fold)
\label{sub:kellerautomat_pDA_}
\begin{itemize}
	\item Ein (nichtdeterministischer) Kellerautomat $M = (Q, \Sigma, \Gamma, q_0, Z_0, \delta, F)$ besteht aus
\begin{itemize}
  \item $Q$, endliche Menge von \textbf{Zuständen}
\item $\Sigma$, endliches \textbf{Eingabealphabet}
\item $\Gamma$, endliches \textbf{Kelleralphabet}
\item $q_0$, \textbf{Startzustand}
\item $Z_0$, \textbf{unterstes Kellerzeichen}
\item $\delta: Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow \mathcal{P}_e(Q \times \Gamma^*)$, \textbf{Übergangsfunktion}
\item $F \subseteq Q$, Menge von \textbf{Endzuständen}
\end{itemize}

\item \textbf{Bedeutung von }$(q', \alpha) \in \delta(q, a, Z)$\textbf{:} Wenn sich $M$ in Zustand $q$ befindet, das Eingabezeichen $a$ liest und $Z$ das oberste Kellerzeichen ist, so kann $M$ im nächsten Schritt in $q'$ übergehen und $Z$ durch $\alpha$ ersetzen.
	\begin{itemize}
	  \item \textbf{POP-Operation:} $\alpha = \epsilon$, das oberste Kellerzeichen $Z$ wird entfernt
	\item \textbf{PUSH-Operation:} $\alpha = Z'Z$, $Z'$ wird als neues oberstes Kellerzeichen gepusht
	\item \textbf{$\epsilon$-Übergang:} $a = \epsilon$, ohne Lesen eines Eingabezeichens
	\end{itemize}

\item Eine \textbf{Konfiguration} eines Kellerautomaten $M$ ist ein Tripel $(q, w, \alpha)$ mit $q \in Q$, $w \in \Sigma^*$ und $\alpha \in \Gamma^*$
	\begin{itemize}
	  \item $q$, der \textbf{momentane Zustand}
	\item $w$, \textbf{noch zu lesende Teil der Eingabe}
	\item $\alpha$, der \textbf{aktuelle Inhalt des Kellers}
	\end{itemize}

\item \textbf{Anfangskonfiguration} von $M$ für die Eingabe $w \in \Sigma^*$ ist $(q_0, w, Z_0)$

\item Auf der Menge aller Konfigurationen definieren wir binäre Relation $\rightarrow_M$:
	\\ \\ \begin{math}
		(q,aw,Z\alpha) \rightarrow_M \left\{
			\begin{array}{ll}
				(q',w,\beta \alpha) & \mbox{falls $(q', \beta) \in \delta(q, a, Z)$}\\
				(q', aw, \beta \alpha) & \mbox{falls $(q', \beta) \in \delta(q, \epsilon, Z)$}
		\end{array}
		\right.
	\end{math}

\item \textbf{Bedeutung von $(q, w, \alpha) \rightarrow_M (q', w',\alpha')$:} Wenn $M$ sich in der Konfiguration $(q, w, \alpha)$ befindet, dann kann er in einen Schritt in die Nachfolgerkonfiguration $(q', w',\alpha')$ übergehen.
\item Eine Konfiguration kann \textbf{mehrere Nachfolgerkonfigurationen} haben $\rightarrow$ \textbf{Nichtdeterminismus}

\item PDA $M$ \textbf{akzeptiert} $w \in \Sigma^*$ \textbf{mit Endzustand} gdw.\ $(q_0, w, Z_0) \rightarrow_M^* (f, \epsilon, \gamma)$ für $f \in F$, $\gamma \in \Gamma^*$

\item PDA $M$ \textbf{akzeptiert} $w \in \Sigma^*$ \textbf{mit leeren Keller} gdw.\ $(q_0, w, Z_0) \rightarrow_M^* (q, \epsilon, \epsilon)$ für $q \in F$
\item Akzeptanz durch Endzustände und leeren Keller \textbf{gleich mächtig}
	
\end{itemize}

\subsection{Endzustand PDA $M$ $\rightarrow$ Leerer Keller PDA $M'$} % (fold)
\label{sub:endzustand_pDA_rightarrow_leerer_keller_pDA}
\begin{itemize}
	\item \textbf{Idee:}
		\begin{enumerate}
			\item Sobald $M$ einen Endzustand erreicht, darf er den Keller leeren $\rightarrow$ $M'$ \textbf{geht in den neuen Nicht-Endzustand} $\overline{q}$ und \textbf{leert dort den Keller}, es gibt \textbf{keine Endzustände mehr}
			\item Verhindern, dass der Keller von $M$ leer wird, ohne dass $M$ in einem Endzustand ist $\rightarrow$ $M'$ hat ein \textbf{neues Symbol} $Z'$ \textbf{ganz unten im Keller} 
		\end{enumerate}
\item $M = (Q, \Sigma, \Gamma, q_0, Z_0, \delta, F)$
\item $M' = (Q', \Sigma, \Gamma', q'_0, Z_0', \delta')$ mit $Q' = Q \uplus \{q'_0, \overline{q}\}$, $\Gamma' = \Gamma \uplus \{Z'_0\}$ und
\begin{itemize}
  
\item $\delta'(q'_0, \epsilon, Z'_0) = \{(q_0, Z_0Z'_0)\}$ $\rightarrow$ \textbf{Übergang von $q'_0$ zu $q_0$}
\item $\delta'(q, a, Z) = \delta(q, a, Z)$ für $q \in Q \setminus F$, $a \in \Sigma \cup \{\epsilon\}$, $Z \in \Gamma$ $\rightarrow$ \textbf{Alle Übergänge zwischen $q$s}
\item $\delta'(f, a, Z) = \delta(f,a,Z)$ für $f \in F$, $a \in \Sigma$, $Z \in \Gamma$ $\rightarrow$ \textbf{Alle Übergänge von Endzuständen zu $q$s}
\item $\delta'(f, \epsilon, Z) = \delta(f, \epsilon, Z) \ \cup \ \{(\overline{q}, Z)\}$ für $Z \in \Gamma$ $\rightarrow$ \textbf{Alle $\epsilon$-Übergänge von Endzuständen zu $q$s und $\overline{q}$}
\item $\delta'(\overline{q}, \epsilon, Z) = \{(\overline{q}, \epsilon)\}$ für $Z \in \Gamma'$ $\rightarrow$ \textbf{Übergang von $\overline{q}$ zu $\overline{q}$ zum Leeren des Kellers}
\end{itemize}

\end{itemize}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.52\linewidth]{endtoleerpda.jpg}
  \label{fig:endtoleerpda_jpg}
\end{figure}

\subsection{Leerer Keller PDA $M$ $\rightarrow$ Endzustand PDA $M'$} % (fold)
\label{sub:leerer_keller_pDA_m_rightarrow_endzustand_pDA_m_}
\begin{itemize}
  \item \textbf{Idee:}
	  \begin{enumerate}
	    \item Es wird am Anfang $Z'_0$ auf Keller geschrieben, damit der Keller nicht geleert wird
		\item Sobald $M$ auf dem Keller $Z'_0$ findet, muss er in den Endzustand gehen, somit ist der Keller am Ende nicht leer $\rightarrow$ $M'$ \textbf{geht in den neuen Endzustand $f$}
	  \end{enumerate}

	 \item $M = (Q, \Sigma, \Gamma, q_0, Z_0, \delta)$
	 \item $M' = (Q', \Sigma, \Gamma', q'_0, Z_0', \delta', F')$ mit $Q' = Q \uplus \{q'_0,f\}$, $\Gamma' = \Gamma \uplus \{Z'_0\}$, $F' = \{f\}$ und
		 \begin{itemize}
			 \item $\delta'(q'_0, \epsilon, Z'_0) = \{(q_0, Z_0Z'_0)\}$ $\rightarrow$ \textbf{Übergang von $q'_0$ zu $q_0$}
			 \item $\delta'(q, a, Z) = \delta(q, a, Z)$ für $q \in Q$, $a \in \Sigma \cup \{\epsilon\}$, $Z \in \Gamma$ $\rightarrow$ \textbf{Alle Übergänge zwischen $q$s}
			 \item $\delta'(q, \epsilon, Z'_0) = \{(f, Z'_0)\}$ für $q \in Q$, $f \in F'$ $\rightarrow$ \textbf{Übergang von $q$ zu $f$ beim Sehen von $Z'_0$}
		 \end{itemize}
\end{itemize}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.52\linewidth]{leertoendpda.jpg}
  \label{fig:leertoendpda_jpg}
\end{figure}


\subsection{Erweiterungslemma} % (fold)
\label{sub:erweiterungslemma}
\begin{itemize}
  \item $(q, u, \alpha) \rightarrow_M^n (q', u', \alpha')$ $\Longrightarrow$ $(q, uv, \alpha \beta) \rightarrow_M^n (q', u'v, \alpha' \beta)$
\begin{itemize}
    \item $q' \in Q$ ist der neue Zustand, den wir in $n$ Schritten erreichen
\item $u' \in \Sigma^*$ ist der noch zu lesende Teil von der Eingabe $u$
\item $\alpha' \in \Gamma^*$ ist der veränderte Kellerinhalt durch das Lesen eines Teils vom Wort $u$, der ganz oben im Keller steht
\item $v \in \Sigma^*$ ist eine neue Eingabe, die mit $u$ konkateniert wird
\item $\beta \in \Gamma^*$ ist der neue Kellerzeichenkette, die ganz unten im Keller steht und während der ganzen Berechnungen unverändert erhalten bleibt

\end{itemize}
\item \textbf{Erweiterungslemma} sagt, dass man \textbf{den Kellerinhalt sowie die Eingabe erweitern} kann, indem man ganz unten im Keller oder ganz hinten in der Eingabe etwas hinzufügt, ohne die Eigenschaft zu zerstören, dass man \textbf{wieder in $n$ gleichen Schritten die gleiche Konfiguration (plus das extra unberührtes Kellerinhalt und die Eingabe) erreichen} kann.

\end{itemize}

\subsection{Zerlegungssatz} % (fold)
\label{sub:zerlegungssatz}
\begin{itemize}
	\item \textbf{Zerlegungssatz} sagt, dass die Berechnung von einem Wort $(q,w,Z_{1 \ldots k}) \rightarrow^n_M (q',\epsilon,\epsilon)$ mit $w = u_1 \ldots u_k$, $Z_i \in \Gamma^*$ \textbf{sich in $k$ Teile zerlegen lässt}, indem man bei jeder Zerlegung \textbf{nur ein Teil} von $w$ liest und zum Lesen \textbf{beliebig viele} PUSH- und POP-Operationen macht \textbf{ohne den Kellerteil von den folgenden Zerlegungen zu berühren (Erweiterungslemma)}.

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.7\linewidth]{zerlegungssatz}
  \label{fig:zerlegungssatz}
\end{figure}

\item $Z_1$ hat die Höhe 4, d.h.\ die Kellerzeichen $Z_2, Z_3, Z_4$ unten werden nicht berührt.

\end{itemize}

\subsection{CFG $\rightarrow$ PDA} % (fold)
\label{sub:_cFG_rightarrow_pDA}
\begin{itemize}
	\item Zu jeder CFG $G$ kann man einen PDA $M$ konstruieren, der mit leerem Keller akzeptiert, so dass $L_{\epsilon}(M) = L(G)$
\item \textbf{Konstruktion:} Bringe alle Produktionen in die Form: $A \rightarrow bB_1 \ldots B_k$ mit $b \in \Sigma \ \cup \ \{\epsilon\}$
	\begin{enumerate}
	\item Füge für jedes Terminal $a\in\Sigma$ ein neues Nichtterminal $X_a$ hinzu
	\item Ersetze alle $a$s ausser dem ersten Terminalzeichen durch $X_a$ in den Produktionen auf der rechten Seite
	\item Füge eine neue Produktion $X_a \rightarrow a$ hinzu
	\item Übersetze die Produktionen in Transitionen von PDA, die Schleifen über einen einzigen Zustand sind:
		\begin{itemize}
			\item $S \rightarrow G$ zu $\epsilon, S / G$
			\item $B \rightarrow bSS$ zu $b, B/SS$
			\item $A \rightarrow a$ zu $a, A/\epsilon$

		\end{itemize}
	\end{enumerate}

\item \textit{\underline{Beispiel:}}
	\begin{figure}[h!]
	  \centering
	  \includegraphics[width=0.3\linewidth]{cfgtopda}
	  \label{fig:cfgtopda}
	\end{figure}
\end{itemize}

\subsection{PDA $\rightarrow$ CFG} % (fold)
\label{sub:pDA_rightarrow_cFG}
\begin{itemize}
	\item Zu jedem PDA $M$, der mit leerem Keller akzeptiert, kann man eine CFG $G$ konstruieren mit $L(G) = L_{\epsilon}(M)$
\item \textbf{Konstruktion:}
	\begin{enumerate}
		\item Für alle $q \in Q$ füge die Produktion $S \rightarrow [q_0, Z_0, q]$
		\item Für alle POP-Operationen $\delta(q, a, Z) = (q', \epsilon)$ füge die Produktion $[q,Z,q'] \rightarrow a$
		\item Für alle PUSH-Operationen $\delta(q, a, Z) = (r_0, Z_1 \ldots Z_k)$ und für alle $r_1 \ldots r_k$ füge die Produktion $[q, Z, r_k] \rightarrow a[r_0, Z_1, r_1][r_1, Z_2, r_2] \ldots [r_{k-1}, Z_k, r_k]$
	\end{enumerate}

\item \textit{\underline{Beispiel:}}
	\begin{figure}[h!]
	  \centering
	  \includegraphics[width=0.65\linewidth]{pdatocfg}
	  \label{fig:pdatocfg}
	\end{figure}
\end{itemize}

\subsection{Deterministisches Kellerautomat (DPDA)} % (fold)
\label{sub:deterministisches_kellerautomat_dPDA_}
\begin{itemize}
  \item Ein PDA ist \textbf{deterministisch} gdw.\ für alle $q \in Q$, $a \in \Sigma$ und $Z \in \Gamma$ gilt $|\delta(q,a,Z)| + |\delta(q, \epsilon, Z)| \le 1$
\item \textbf{NPDA} ist \textbf{mächtiger} als \textbf{DPDA}
\item CFL ist \textbf{deterministisch} (DCFL) gdw.\ sie \textbf{von einem DPDA akzeptiert} wird
\item Jede \textbf{reguläre Sprache} ist eine \textbf{CFL}

\item Die vom leeren Keller akzeptierten DCFLs sind die Sprachen, die \textbf{vom Endzustand akzeptiert} werden und \textbf{präfixfrei} sind: Kein Wort in der Sprache ist die Präfix eines anderen Wortes in der Sprache

\item Jede DCFL ist \textbf{nicht inhärent mehrdeutig}, d.h.\ sie wird von einer \textbf{nicht-mehrdeutigen Grammatik} erzeugt

\end{itemize}

\subsection{Abschlusseigenschaften der CFLs} % (fold)
\label{sub:abschlusseigenschaften_der_cFLs}
Seien $L$, $L_1$, $L_2 \subseteq \Sigma^*$ kontextfreie Sprachen, dann sind auch
\begin{itemize}
  \item $L_1 \cup L_2$
\item $L_1L_2$
\item $L^*$
\item $L^R$
\item $L_1 \times L_2$
\end{itemize}


\subsection{Abschlusseigenschaften der DCFLs} % (fold)
\label{sub:abschlusseigenschaften_der_DCFLs}
Sei $L$ $\subseteq \Sigma^*$ eine deterministische kontextfreie Sprache, dann ist auch
\begin{itemize}
	\item $\overline{L}$
\end{itemize}

\section{Abschlusseigenschaften und Entscheidbarkeit} % (fold)
\label{sec:überblick_abschlusseigenschaften_und_entscheidbarkeit}

\subsection{Abschlusseigenschaften} % (fold)
\label{sub:abschlusseigenschaften}

\begin{tabular}{|c||c||c||c||c||c||c||c|}
\hline
 & $L_1\cap L_2$ & $L_1 \cup L_2$ & $\overline{L}$ & $L_1\times L_2$ & $L^*$ & $L_1L_2$ & $L^R$ \\ \hline
	\textbf{Regulär} & ja & ja & ja & ja & ja & ja & ja\\ \hline
\textbf{CFL} & nein & ja & nein & ja & ja & ja & ja\\ \hline
\textbf{DCFL} & nein & nein & ja & nein & nein & nein & nein \\ \hline
\end{tabular}

\pagebreak

\subsection{Entscheidbarkeit} % (fold)
\label{sub:entscheidbarkeit}

\begin{tabular}{|c||c||c||c||c||c|}
\hline
 & \textbf{Wort} & \textbf{Leerheit} & \textbf{Äquivalenz} & \textbf{Schnitt} & \textbf{Endlichkeit} \\ \hline
	\textbf{DFA} & ja & ja & ja & ja & ja\\ \hline
\textbf{NFA} & ja & ja & ja & ja & ja \\ \hline
\textbf{CFG} & ja & ja & ja & nein & ja \\ \hline
\textbf{DPDA} & ja & ja & nein & nein & ja \\ \hline
\end{tabular}

\vspace*{0.5cm}

\hspace{-0.52cm}\begin{tabular}{|c||c||c|}
\hline
 & \textbf{Regularität} & \textbf{Mehrdeutigkeit} \\ \hline
\textbf{CFG} & nein & nein  \\ \hline
\textbf{DPDA} & ja & ja  \\ \hline
\end{tabular}

\section{Berechenbarkeit, Entscheidbarkeit} % (fold)
\label{sec:berechenbarkeit_entscheidbarkeit}

\subsection{Grundbegriffe der Berechenbarkeit} % (fold)
\label{sub:berechenbarkeit}
\begin{itemize}
	\item Funktion $f: \mathbb{N}^k \rightarrow \mathbb{N}$ ist \textbf{berechenbar}, wenn es \textbf{einen Algorithmus gibt}, der bei Eingabe $(n_1, \ldots, n_k) \in \mathbb{N}^k$
	\begin{itemize}
	  \item \textbf{nach endlich vielen Schritten} mit Ergebnis $f(n_1, \ldots, n_k)$ \textbf{hält}, falls $f(n_1, \ldots, n_k)$ \textbf{definiert} ist
	\item \textbf{nicht terminiert}, falls $f(n_1, \ldots, n_k)$ \textbf{nicht definiert} ist 
	\end{itemize}


\item Funktion $f: A \rightarrow B$ ist
	\begin{itemize}
	  \item \textbf{total} gdw.\ $f(a)$ für alle $a \in A$ definiert ist
	\item \textbf{partiell} gdw.\ $f(a)$ für beliebige oder keine $a \in A$ definiert ist
	\item \textbf{echt partiell} gdw.\ sie nicht total ist
	\end{itemize}

\item \textbf{Jeder Algorithmus} berechnet eine \textbf{partielle Funktion}
	\begin{itemize}
	  \item \textit{\underline{Beispiel 1:}} Algorithmus
		  $input(n);$
		  $while \ true \ do;$ berechnet die überall undefinierte partielle Funktion, d.h.\ $\emptyset \subset \mathbb{N} \rightarrow \mathbb{N}$

	\end{itemize}
	\item \textit{\underline{Beispiel 2:}} \begin{math}
		f(n) \left\{
			\begin{array}{ll}
				1 & \hspace{-6.35cm} \mbox{falls $n$ als Ziffernfolge Anfangsstück}\\ \hspace{1cm}\mbox{der Dezimalbruchentwicklung von $\pi$ ist}\\
				0 & \hspace{-6.35cm}\mbox{sonst}
		\end{array}
		\right.
	\end{math}
\\\\ $f$ ist berechenbar ($f(314) = 1$, $f(315) = 0$), denn es Algorithmen gibt, die $\pi$ iterativ auf beliebig viele Dezimalstellen genau berechnet werden.
		
\item \textit{\underline{Beispiel 3:}} \begin{math}
		f(n) \left\{
			\begin{array}{ll}
				1 & \hspace{-6.35cm} \mbox{falls $n$ als Ziffernfolge irgendwo in}\\ \hspace{1cm}\mbox{der Dezimalbruchentwicklung von $\pi$ ist}\\
				0 & \hspace{-6.35cm}\mbox{sonst}
		\end{array}
		\right.
	\end{math}
\\\\ Es ist unbekannt, ob $f$ berechenbar ist. Wie stellt man fest, dass $n$ nicht vorkommt, wenn der Dezimalbruchentwicklung nie terminiert?

\pagebreak

\item \textit{\underline{Beispiel 4:}} \begin{math}
		f(n) \left\{
			\begin{array}{ll}
				1 & \hspace{-6.4cm} \mbox{falls 10 mal hintereinander Nullen in}\\ \hspace{1cm}\mbox{der Dezimalbruchentwicklung von $\pi$ ist}\\
				0 & \hspace{-6.35cm}\mbox{sonst}
		\end{array}
		\right.
	\end{math}
\\\\ $f$ ist berechenbar, denn $f$ ist entweder die konstante Funktion, die $1$ für alle $n\ge0$ zurückgibt, oder die Funktion, die $0$ für alle $n\ge 0$ zurückgibt. Beide sind berechenbar.
\\\\ Das ist ein \textbf{nicht-konstruktiver Beweis:} Wir wissen, es gibt einen Algorithmus, der $f$ berechnet, aber \textbf{wissen nicht, welcher}.

\item Es gibt \textbf{nicht berechenbare} Funktionen $\mathbb{N} \rightarrow \{0,1\}$
	\begin{itemize}
		\item Es gibt \textbf{abzählbar} viele Algorithmen, aber \textbf{überabzählbar} viele Funktionen in $\mathbb{N} \rightarrow \{0,1\}$ 
	\end{itemize}

\end{itemize}







\end{document}
